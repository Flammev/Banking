"""
Input validation helpers for Rift Pay.

These functions validate user-supplied data before it reaches the database or
other application logic, providing a defence-in-depth layer against common
web vulnerabilities such as XSS and SQL injection.
"""

import re

# ── compiled patterns ──────────────────────────────────────────────────────────

# Personal name: Latin letters (including common accented characters), spaces,
# apostrophes (e.g. O'Brien), hyphens (e.g. Jean-Pierre), 1–100 characters.
_NAME_RE = re.compile(r"^[A-Za-zÀ-ÖØ-öø-ÿ' \-]{1,100}$")

# RFC-5321-style e-mail (simplified but covers all common cases).
_EMAIL_RE = re.compile(r"^[a-zA-Z0-9._%+\-]+@[a-zA-Z0-9.\-]+\.[a-zA-Z]{2,}$")

# Phone: optional leading +, then digits / spaces / hyphens / parentheses,
# resulting in 8–15 digits after stripping non-digit characters.
_PHONE_RE = re.compile(r"^\+?[\d\s\-\(\)]{8,20}$")

# Account numbers generated by this application (e.g. "ACC1234567890").
_ACCOUNT_RE = re.compile(r"^ACC\d{10}$")

# OTP: exactly 6 digits.
_OTP_RE = re.compile(r"^\d{6}$")

# XSS / script-injection patterns.
_XSS_RE = re.compile(
    r"<\s*script|javascript:|vbscript:|on\w+\s*=|<\s*iframe|"
    r"<\s*object|<\s*embed|data:\s*text/html",
    re.IGNORECASE,
)

# Obvious SQL-injection sequences (multi-keyword pairs and comment/terminator tricks).
_SQL_RE = re.compile(
    r"(\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|UNION|TRUNCATE|DECLARE)\b"
    r".*\b(FROM|INTO|TABLE|WHERE|SET)\b)"
    r"|--\s*$"
    r"|;\s*(DROP|DELETE|INSERT|UPDATE|CREATE|ALTER|EXEC)\b",
    re.IGNORECASE | re.DOTALL,
)

# ── public functions ───────────────────────────────────────────────────────────


def is_valid_name(value: str) -> bool:
    """Return True if *value* is a plausible personal name.

    Accepts letters (including common accented characters), spaces, apostrophes,
    and hyphens; length 1–100 characters.
    """
    return bool(value and _NAME_RE.match(value.strip()))


def is_valid_email(value: str) -> bool:
    """Return True if *value* looks like a valid e-mail address.

    Enforces the RFC 5321 maximum length of 254 characters.
    """
    if not value:
        return False
    stripped = value.strip()
    return len(stripped) <= 254 and bool(_EMAIL_RE.match(stripped))


def is_valid_phone(value: str) -> bool:
    """Return True if *value* is a plausible phone number.

    Accepts an optional leading '+', then digits, spaces, hyphens, and
    parentheses; the raw string must be 8–20 characters long.
    """
    return bool(value and _PHONE_RE.match(value.strip()))


def is_valid_password(value: str) -> bool:
    """Return True if *value* meets the minimum password policy.

    Requirements: 8–128 characters, at least one letter, at least one digit.
    The maximum length prevents potential DoS via extremely large inputs.
    """
    if not value or len(value) < 8 or len(value) > 128:
        return False
    return any(c.isalpha() for c in value) and any(c.isdigit() for c in value)


def is_valid_account_number(value: str) -> bool:
    """Return True if *value* matches the expected account-number format."""
    return bool(value and _ACCOUNT_RE.match(value.strip()))


def is_valid_otp(value: str) -> bool:
    """Return True if *value* is a 6-digit OTP code."""
    return bool(value and _OTP_RE.match(value.strip()))


def is_safe_text(value: str) -> bool:
    """Return True if *value* contains no XSS or SQL-injection patterns.

    Intended for free-text fields (e.g. transfer description) that do not need
    to contain HTML or structured query syntax.

    Note: Django's ORM already prevents SQL injection through parameterised
    queries.  This check is a defence-in-depth layer that also provides an
    audit signal when suspicious input is submitted.  It does not replace
    proper output escaping (handled by Django's template engine) or ORM-level
    protection.
    """
    if not value:
        return True
    return not (_XSS_RE.search(value) or _SQL_RE.search(value))
